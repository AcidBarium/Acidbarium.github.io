import{_ as f}from"./ValaxyMain.vue_vue_type_style_index_0_lang.IVu3v1-4.js";import{f as h,a as P}from"./chunks/vue-router.DDVc9App.js";import{A as p,N as g,a3 as a,U as t,S as l,W as e,u as b,O as L}from"./framework.MaWbPGGC.js";import"./app.DIG8ASj4.js";import"./chunks/dayjs.DRNXKsfK.js";import"./chunks/vue-i18n.PIml-ud3.js";import"./chunks/pinia.DQTuBk3f.js";import"./chunks/@vueuse/motion.B_4jFum_.js";import"./chunks/nprogress.Y9-A6VbA.js";import"./YunComment.vue_vue_type_style_index_0_lang.ChocsJ8O.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.C5XaEs4c.js";import"./post.BW3-DAXA.js";const v=h("/posts/llvmDevelop",async r=>JSON.parse('{"title":"LLVM-Pass发展随笔","description":"","frontmatter":{"title":"LLVM-Pass发展随笔","date":"2025-06-24","updated":"2025-10-13","categories":"LLVM","tags":["笔记","pass"]},"headers":[{"level":2,"title":"这段代码是干嘛的？","slug":"这段代码是干嘛的","link":"#这段代码是干嘛的","children":[]},{"level":2,"title":"为什么 LLVM 13 没有，LLVM 19 才有？","slug":"为什么-llvm-13-没有-llvm-19-才有","link":"#为什么-llvm-13-没有-llvm-19-才有","children":[{"level":3,"title":"原因：","slug":"原因","link":"#原因","children":[]}]},{"level":2,"title":"📜 背景演化时间线：","slug":"📜-背景演化时间线","link":"#📜-背景演化时间线","children":[]},{"level":2,"title":"它们解决的问题：","slug":"它们解决的问题","link":"#它们解决的问题","children":[{"level":3,"title":"▶ 加速代码裁剪（AcceleratorCodeSelection）","slug":"▶-加速代码裁剪-acceleratorcodeselection","link":"#▶-加速代码裁剪-acceleratorcodeselection","children":[]}]}],"relativePath":"pages/posts/llvmDevelop.md","lastUpdated":1761807823000}'),{lazy:(r,i)=>r.name===i.name}),O={__name:"llvmDevelop",setup(r,{expose:i}){var u;const{data:s}=v(),d=P(),o=Object.assign(d.meta.frontmatter||{},((u=s.value)==null?void 0:u.frontmatter)||{});return d.meta.frontmatter=o,p("pageData",s.value),p("valaxy:frontmatter",o),globalThis.$frontmatter=o,i({frontmatter:{title:"LLVM-Pass发展随笔",date:"2025-06-24",updated:"2025-10-13",categories:"LLVM",tags:["笔记","pass"]}}),(n,c)=>{const m=f;return L(),g(m,{frontmatter:b(o)},{"main-content-md":a(()=>[...c[0]||(c[0]=[l("h1",{id:"coroconditionalwrapper",tabindex:"-1"},[e("CoroConditionalWrapper "),l("a",{class:"header-anchor",href:"#coroconditionalwrapper","aria-label":'Permalink to "CoroConditionalWrapper"'},"​")],-1),l("p",null,[e("在 LLVM 19 中，"),l("code",null,"CoroConditionalWrapper"),e(" 被引入作为一个新的 "),l("strong",null,"Module‑level Pass 包装器"),e("，它的关键作用是——")],-1),l("ol",null,[l("li",null,[l("p",null,[l("strong",null,"减少不必要的开销"),e(" 并非所有模块都使用协程。此包装器先通过简单检查（是否声明有协程 Intrinsic）来决定：")]),l("ul",null,[l("li",null,"若无协程部分，直接跳过后续所有协程 Pass"),l("li",null,[e("若包含协程，再按顺序执行像 "),l("code",null,"CoroEarly"),e("、"),l("code",null,"CoroSplit"),e("、"),l("code",null,"CoroElide"),e("、"),l("code",null,"CoroCleanup"),e(" 的 Pass ([releases.llvm.org][1], [llvm.org][2])")])])]),l("li",null,[l("p",null,[l("strong",null,"提高编译效率与可维护性"),e(" 避免每次遍历都运行涉及协程分析、修改的代码，提高编译整体性能。")])])],-1),l("p",null,[l("code",null,"CoroConditionalWrapper"),e(" 内部持有一个 "),l("code",null,"ModulePassManager PM"),e("，流水线里注册了多个协程优化 Pass：")],-1),l("ul",null,[l("li",null,[l("strong",null,"引入时间"),e("：LLVM 19，为稳定支持 C++20 协程")]),l("li",null,[l("strong",null,"目的"),e("：让协程 Pass 更“懒惰”——只在必要时才执行")]),l("li",null,[l("strong",null,"优点"),e("：节省编译时间、提高构建效率、提升代码整洁性")])],-1),l("hr",null,null,-1),l("h1",{id:"hipstdpar",tabindex:"-1"},[e("HipStdPar "),l("a",{class:"header-anchor",href:"#hipstdpar","aria-label":'Permalink to "HipStdPar"'},"​")],-1),l("h2",{id:"这段代码是干嘛的",tabindex:"-1"},[e("这段代码是干嘛的？ "),l("a",{class:"header-anchor",href:"#这段代码是干嘛的","aria-label":'Permalink to "这段代码是干嘛的？"'},"​")],-1),l("p",null,[e("这是 LLVM 19 中新增的"),l("strong",null,"HIP stdpar 支持 Pass 定义"),e("，专门服务于 C++ "),l("code",null,"std::execution::par"),e(" 并行算法映射到 AMD GPU 的 "),l("strong",null,"标准并行性实现（stdpar runtime on HIP backend）"),e("。")],-1),l("blockquote",null,[l("p",null,[l("strong",null,"作用概括"),e("：")])],-1),l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"HipStdParAcceleratorCodeSelectionPass"),e(" → 剪裁模块，只保留从 GPU kernel 可达的函数，删除其他无用代码（device 代码空间宝贵）")])]),l("li",null,[l("p",null,[l("strong",null,"HipStdParAllocationInterpositionPass"),e(" → 将 "),l("code",null,"malloc"),e(" / "),l("code",null,"free"),e(" / "),l("code",null,"operator new"),e(" 这些分配调用替换成 GPU runtime 提供的版本，保证 device kernel 运行时分配的内存是 GPU 端合法、可用的。")])])],-1),l("h2",{id:"为什么-llvm-13-没有-llvm-19-才有",tabindex:"-1"},[e("为什么 LLVM 13 没有，LLVM 19 才有？ "),l("a",{class:"header-anchor",href:"#为什么-llvm-13-没有-llvm-19-才有","aria-label":'Permalink to "为什么 LLVM 13 没有，LLVM 19 才有？"'},"​")],-1),l("h3",{id:"原因",tabindex:"-1"},[e("原因： "),l("a",{class:"header-anchor",href:"#原因","aria-label":'Permalink to "原因："'},"​")],-1),l("p",null,[l("strong",null,[e("LLVM 13（2021 年）并不支持 C++20 "),l("code",null,"std::execution::par"),e(" 并行算法在 GPU（尤其是 AMD HIP）上的 offloading。")])],-1),l("p",null,[e("而"),l("strong",null,[e("LLVM 18/19 才正式引入完整的 "),l("code",null,"stdpar"),e(" 支持")]),e("：")],-1),l("ul",null,[l("li",null,[e("C++ "),l("code",null,"std::execution::par"),e("/"),l("code",null,"par_unseq"),e(" 算法通过 "),l("strong",null,"offload 到 GPU kernel")]),l("li",null,[e("LLVM 19 在 HIP backend 上做了这一套 stdpar device offloading 支持，称为 "),l("strong",null,"HIP stdpar runtime"),e("。")])],-1),l("blockquote",null,[l("p",null,"这个功能实现过程中，需要：")],-1),l("ol",null,[l("li",null,"剪枝优化（AcceleratorCodeSelection）"),l("li",null,"内存分配替换（AllocationInterposition）")],-1),l("p",null,"→ 就是你看到的这两个 Pass。",-1),l("hr",null,null,-1),l("h2",{id:"📜-背景演化时间线",tabindex:"-1"},[e("📜 背景演化时间线： "),l("a",{class:"header-anchor",href:"#📜-背景演化时间线","aria-label":'Permalink to "📜 背景演化时间线："'},"​")],-1),l("table",null,[l("thead",null,[l("tr",null,[l("th",{style:{"text-align":"left"}},"LLVM 版本"),l("th",{style:{"text-align":"left"}},"状态")])]),l("tbody",null,[l("tr",null,[l("td",{style:{"text-align":"left"}},"LLVM 13"),l("td",{style:{"text-align":"left"}},"没有 stdpar offload 支持，C++ 并行算法执行仍然是纯 CPU 并行")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"LLVM 15"),l("td",{style:{"text-align":"left"}},"初步在 NVIDIA CUDA 下探索 stdpar runtime prototype")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"LLVM 17"),l("td",{style:{"text-align":"left"}},"stdpar runtime 基础设施逐渐向 HIP 和 OpenMP port")]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"LLVM 19")]),l("td",{style:{"text-align":"left"}},"正式在 HIP backend 实现稳定版 stdpar runtime offloading，加入这两个专门 Pass")])])],-1),l("hr",null,null,-1),l("h2",{id:"它们解决的问题",tabindex:"-1"},[e("它们解决的问题： "),l("a",{class:"header-anchor",href:"#它们解决的问题","aria-label":'Permalink to "它们解决的问题："'},"​")],-1),l("h3",{id:"▶-加速代码裁剪-acceleratorcodeselection",tabindex:"-1"},[e("▶ 加速代码裁剪（AcceleratorCodeSelection） "),l("a",{class:"header-anchor",href:"#▶-加速代码裁剪-acceleratorcodeselection","aria-label":'Permalink to "▶ 加速代码裁剪（AcceleratorCodeSelection）"'},"​")],-1),l("p",null,"GPU 端 kernel 只需用到极少部分 std 算法和 helper 函数，module 中其他未用函数多余占空间、可能连带其他依赖，导致 device 代码增大。 → 这个 pass 自动剔除不可达函数。",-1),l("h4",{id:"内存分配替换-allocationinterposition",tabindex:"-1"},[e("内存分配替换（AllocationInterposition） "),l("a",{class:"header-anchor",href:"#内存分配替换-allocationinterposition","aria-label":'Permalink to "内存分配替换（AllocationInterposition）"'},"​")],-1),l("p",null,[e("GPU kernel 中不能直接用 host 版 "),l("code",null,"malloc"),e("，否则 runtime error。 → 这个 pass 将所有 "),l("code",null,"malloc"),e("/"),l("code",null,"free"),e(" 改写为 HIP runtime 中的 GPU 可访问内存分配函数。")],-1),l("p",null,"| LLVM 13 | 没有 GPU stdpar 支持，故无这类 pass | | LLVM 19 | 实现了 stdpar on HIP backend，需要这两个 pass 确保 offloading 正确、高效 |",-1),l("p",null,[e("在 LLVM 19 的 "),l("code",null,"/lib/llvm-19/include/llvm/Transforms/IPO"),e(" 目录下，存在多个与 Interprocedural Optimization（IPO，跨过程优化）相关的 Pass 文件。这些 Pass 主要用于模块级别的优化，涉及函数、全局变量、调用约定等方面。以下是对您提到的三个头文件的详细说明：")],-1),l("hr",null,null,-1),l("h1",{id:"ipo",tabindex:"-1"},[e("IPO "),l("a",{class:"header-anchor",href:"#ipo","aria-label":'Permalink to "IPO"'},"​")],-1),l("p",null,"这些 Pass 可以在 LLVM 的优化阶段被调用，处理跨函数的分析与变换",-1),l("h1",{id:"embedbitcodepass",tabindex:"-1"},[e("EmbedBitcodePass "),l("a",{class:"header-anchor",href:"#embedbitcodepass","aria-label":'Permalink to "EmbedBitcodePass"'},"​")],-1),l("p",null,[l("strong",null,"功能概述："),e(" 该 Pass 会克隆当前模块，并在克隆上运行指定的 Pass 管道。优化后的模块会被存储到 "),l("code",null,".llvm.lto"),e(" 节中的全局变量中。主要用于支持 FatLTO（Fat Link Time Optimization）管道，但也可用于在不改变当前模块的情况下，为任何任意的 Pass 管道生成 Bitcode 节。 ([llvm.org][1])")],-1),l("p",null,[l("strong",null,"用途："),e(" 将优化后的模块嵌入到当前模块中，通常用于链接时优化（LTO）过程中，以便在链接阶段进行进一步的优化。")],-1),l("h1",{id:"expandvariadics",tabindex:"-1"},[e("ExpandVariadics "),l("a",{class:"header-anchor",href:"#expandvariadics","aria-label":'Permalink to "ExpandVariadics"'},"​")],-1),l("p",null,[l("strong",null,"功能概述："),e(" 该 Pass 用于展开变参函数（variadic functions）。通过将变参函数转换为固定参数的函数，可以使其更容易进行优化。")],-1),l("p",null,[l("strong",null,[e("枚举类型 "),l("code",null,"ExpandVariadicsMode"),e("：")])],-1),l("ul",null,[l("li",null,[l("code",null,"Unspecified"),e("：使用实现默认值。")]),l("li",null,[l("code",null,"Disable"),e("：完全禁用此 Pass。")]),l("li",null,[l("code",null,"Optimize"),e("：在不改变 ABI 的情况下进行优化。")]),l("li",null,[l("code",null,"Lowering"),e("：改变变参调用约定。 ")])],-1),l("p",null,[l("strong",null,"用途："),e(" 优化变参函数的调用约定，使其更适合目标平台的优化工具（如 GlobalISel）。")],-1),l("h1",{id:"extractgv",tabindex:"-1"},[e("ExtractGV "),l("a",{class:"header-anchor",href:"#extractgv","aria-label":'Permalink to "ExtractGV"'},"​")],-1),l("p",null,[l("strong",null,"功能概述："),e(" 该 Pass 用于从模块中提取指定的全局变量（Global Values）。")],-1),l("p",null,[l("strong",null,"构造函数参数：")],-1),l("ul",null,[l("li",null,[l("code",null,"GVs"),e("：要提取的全局变量列表。")]),l("li",null,[l("code",null,"deleteS"),e("：如果为 "),l("code",null,"true"),e("，则删除指定的全局变量；否则，尽可能删除模块中的其他内容，保留指定的全局变量。")]),l("li",null,[l("code",null,"keepConstInit"),e("：如果为 "),l("code",null,"true"),e("，则保留常量初始化。 ([llvm.org][3])")])],-1),l("p",null,[l("strong",null,"用途："),e(" 将指定的全局变量从模块中提取出来，通常用于生成独立的模块或进行模块拆分。")],-1),l("h1",{id:"functionspecialization",tabindex:"-1"},[e("FunctionSpecialization "),l("a",{class:"header-anchor",href:"#functionspecialization","aria-label":'Permalink to "FunctionSpecialization"'},"​")],-1),l("p",null,"该 Pass 实现了函数特化（Function Specialization）优化。它通过将函数调用中的常量参数传播到被调用函数，从而生成特化版本的函数。此过程是跨过程稀疏条件常量传播（IPSCCP）的一部分。该 Pass 支持多次迭代，以处理递归函数和新的特化机会。",-1),l("h1",{id:"memprofcontextdisambiguation",tabindex:"-1"},[e("MemProfContextDisambiguation "),l("a",{class:"header-anchor",href:"#memprofcontextdisambiguation","aria-label":'Permalink to "MemProfContextDisambiguation"'},"​")],-1),l("p",null,"该传递用于内存分配的上下文消歧（Context Disambiguation）。MemProfContextDisambiguation 传递的作用是根据内存分配的上下文信息（如热/冷分配）来优化堆内存的使用。它利用 memprof 元数据来区分不同的内存分配上下文，从而进行更精细的优化。",-1),l("p",null,"功能：根据内存分配的上下文信息优化堆内存的使用。 应用：用于配置文件引导的堆优化。",-1),l("h1",{id:"moduleinliner",tabindex:"-1"},[e("ModuleInliner "),l("a",{class:"header-anchor",href:"#moduleinliner","aria-label":'Permalink to "ModuleInliner"'},"​")],-1),l("p",null,[l("code",null,"ModuleInlinerPass"),e(" 是 LLVM 新的 Pass 管理器中的一个模块级函数内联优化 Pass。它将内联工具和内联成本分析结合成一个模块级的 Pass，旨在对整个模块中的函数调用进行分析，并在合适的情况下执行内联操作，以提高程序性能。")],-1),l("p",null,"模块级分析：与 SCC（强连通分量）内联器不同，ModuleInlinerPass 会考虑整个模块中每个函数的每个调用，进行全局内联决策。",-1),l("p",null,"启用更多启发式分析：可以在模块级别评估更多的启发式策略，例如 PriorityInlineOrder，以优化内联顺序。",-1),l("p",null,"可调节的成本模型：通过参数配置，用户可以控制使用的成本模型和内联决策中的权衡策略。",-1),l("hr",null,null,-1),l("h1",{id:"flattencfg",tabindex:"-1"},[e("FlattenCFG "),l("a",{class:"header-anchor",href:"#flattencfg","aria-label":'Permalink to "FlattenCFG"'},"​")],-1),l("p",null,"FlattenCFG 是 LLVM 中的一个 Control‑Flow Flattening（控制流扁平化） 工具函数，位于 Transforms/Utils/Local.h，用于简化和合并函数中的控制流图（CFG）。它会尝试将 if 结构中的分支并联成单个分支块，并将多个 if 段之间的相似代码合并，从而降低控制流复杂度",-1),l("h1",{id:"inferalignment",tabindex:"-1"},[e("InferAlignment "),l("a",{class:"header-anchor",href:"#inferalignment","aria-label":'Permalink to "InferAlignment"'},"​")],-1),l("p",null,'InferAlignmentPass 是 LLVM 中一个 Scalar IR 级优化通用通道，其目的是根据已知指针底层对象对齐信息（已知最低有效零位数，即 "trailing zero known bits"），推断更大的对齐值，并把它添加到内存操作（load/store、memcpy 等）的 alignment 属性中，以便后端利用对齐提升代码质量和性能',-1),l("p",null,"推断对齐可以让后端生成更有效指令：如果确定某个内存访问是 16 字节对齐的，就可使用更高效的aligned 指令序列。",-1),l("p",null,"减轻 InstCombine 的压力：先前 InstCombine 已具备部分对齐推断能力，但每次 run 会重复检查对象。此 pass 将其提取出来单独运行，大大减少冗余，提升效率",-1),l("p",null,"在 IR 优化流水线上适时运行，确保对齐信息稳定后传递给最终代码生成阶段 。",-1),l("h1",{id:"placesafepoints",tabindex:"-1"},[e("PlaceSafepoints "),l("a",{class:"header-anchor",href:"#placesafepoints","aria-label":'Permalink to "PlaceSafepoints"'},"​")],-1),l("p",null,"PlaceSafepointsPass 是 LLVM 在 IR 级别用于 插入垃圾回收 (GC) safepoint（安全点） 的 Scalar 优化 Pass，它并不负责实际重写变量或栈帧，而只是 在函数中插入检查点。",-1)])]),"main-header":a(()=>[t(n.$slots,"main-header")]),"main-header-after":a(()=>[t(n.$slots,"main-header-after")]),"main-nav":a(()=>[t(n.$slots,"main-nav")]),"main-content-before":a(()=>[t(n.$slots,"main-content-before")]),"main-content":a(()=>[t(n.$slots,"main-content")]),"main-content-after":a(()=>[t(n.$slots,"main-content-after")]),"main-nav-before":a(()=>[t(n.$slots,"main-nav-before")]),"main-nav-after":a(()=>[t(n.$slots,"main-nav-after")]),comment:a(()=>[t(n.$slots,"comment")]),footer:a(()=>[t(n.$slots,"footer")]),aside:a(()=>[t(n.$slots,"aside")]),"aside-custom":a(()=>[t(n.$slots,"aside-custom")]),default:a(()=>[t(n.$slots,"default")]),_:3},8,["frontmatter"])}}};export{O as default,v as usePageData};
